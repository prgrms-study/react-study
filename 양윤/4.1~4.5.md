# 5일차

## 01. API연동의 기본

axios를 사용해서 GET, PUT, POST, DELETE 등의 메서드로 API 요청

사용법

```jsx
import axios from 'axios'; 

// 메서드 이름을 소문자로
// 파라미터에는 API 의 주소
axios.get('/users/1'); 

//post일 시 두번 째 파라미터로 등록하려는 정보를 넣는다
axios.post('/users', {
  username: 'blabla',
  name: 'blabla'
});
```

### **useState 와 useEffect 로 데이터 로딩하기**

useState: 요청 상태 관리 (요청 결과, 로딩 상태, 에러)

```jsx
const [users, setUsers] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);
```

useEffect: 렌더링 시점에 요청 시작

```jsx
useEffect(() => { // 파라미터 함수에는 async사용 불가
    const fetchUsers = async () => { // async함수 따로 만들어줘야 함
      try {
        // 요청이 시작 시 error 와 users 를 초기화
        setError(null);
        setUsers(null);
        // loading 상태 true로 변경
        setLoading(true);
        const response = await axios.get(
          'https://jsonplaceholder.typicode.com/users'
        );
        setUsers(response.data); // response.data를 users에 할당한다
      } catch (e) {
        setError(e);
      }
      setLoading(false); // 요청 끝나고 false로 변경
    };

    fetchUsers();
  }, []);
```

이벤트로 axios함수를 호출하려면 `fetchUsers` 함수를 바깥으로 꺼내주고, 컴포넌트에 이벤트 핸들러로 전달해주면 된다

```jsx
// 따로 생성
const fetchUsers = async () => {
    try {
      // 요청이 시작 할 때에는 error 와 users 를 초기화하고
      setError(null);
      setUsers(null);
      // loading 상태를 true 로 바꿉니다.
      setLoading(true);
      const response = await axios.get(
        'https://jsonplaceholder.typicode.com/users'
      );
      setUsers(response.data); // 데이터는 response.data 안에 들어있습니다.
    } catch (e) {
      setError(e);
    }
    setLoading(false);
  };

useEffect(() => {
    fetchUsers(); // 처음 렌더링 시 호출
  }, []);

return (
    <>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.username} ({user.name})
          </li>
        ))}
      </ul>
      <button onClick={fetchUsers}>다시 불러오기</button> // 버튼 클릭 시 호출
    </>
  );
```

---

## **02. useReducer 로 요청 상태 관리하기**

`useState` 대신에 `useReducer` 를 사용해서 구현할 수 있다

**장점**

- `setState` 함수를 여러번 사용하지 않아도 된다
- 리듀서로 로직을 분리했기 때문에 다른 곳에서도 쉽게 재사용 할 수 있다

```jsx

// 각 action이 일어 났을 때의 3가지 상태를 설정해서 리턴한다
function reducer(state, action) {
  switch (action.type) {
    case 'LOADING':
      return {
        loading: true,
        data: null,
        error: null
      };
    case 'SUCCESS':
      return {
        loading: false,
        data: action.data,
        error: null
      };
    case 'ERROR':
      return {
        loading: false,
        data: null,
        error: action.error
      };
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

// useReducer의 2번째 인자로 초기 상태를 설정해준다
const [state, dispatch] = useReducer(reducer, {
    loading: false,
    data: null,
    error: null
  });

const fetchUsers = async () => {
    dispatch({ type: 'LOADING' }); // 로딩 상태 바꾸기
    try {
      const response = await axios.get(
        'https://jsonplaceholder.typicode.com/users'
      );
      dispatch({ type: 'SUCCESS', data: response.data }); // 받아온 데이터 넘기기
    } catch (e) {
      dispatch({ type: 'ERROR', error: e }); // 에러 넘기기
    }
  };

const { loading, data: users, error } = state; // 각 상태를 꺼내서 조건에 맞게 렌더링한다

  if (loading) return <div>로딩중..</div>;
  if (error) return <div>에러가 발생했습니다</div>;
  if (!users) return null;
```

---

## 0**3. useAsync 커스텀 Hook 만들어서 사용하기**

데이터를 요청해야 할 때마다 리듀서를 작성하는 것은 번거로운 일,
커스텀 Hook 을 만들어서 요청 상태 관리 로직을 쉽게 재사용 할 수 있다

**useAsync.js**

useReducer, fetchData함수와 useEffect로 처음 렌더링 시 호출해주는 로직을 useAsync함수에 넣어서 

state와 fetchData를 반환해준다

```jsx
import { useReducer, useEffect } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'LOADING':
      return {
        loading: true,
        data: null,
        error: null
      };
    case 'SUCCESS':
      return {
        loading: false,
        data: action.data,
        error: null
      };
    case 'ERROR':
      return {
        loading: false,
        data: null,
        error: action.error
      };
    default:
      throw new Error(`Unhandled action type: ${action.type}`);
  }
}

function useAsync(callback, deps = []) {
  const [state, dispatch] = useReducer(reducer, {
    loading: false,
    data: null,
    error: false
  });

  const fetchData = async () => {
    dispatch({ type: 'LOADING' });
    try {
      const data = await callback();
      dispatch({ type: 'SUCCESS', data });
    } catch (e) {
      dispatch({ type: 'ERROR', error: e });
    }
  };

  useEffect(() => {
    fetchData();
    // eslint 설정을 다음 줄에서만 비활성화
    // eslint-disable-next-line
  }, deps);

  return [state, fetchData];
}

export default useAsync;
```

사용하기

```jsx
function Users() {

	// state와 fetch함수를 꺼낸다
  const [state, refetch] = useAsync(getUsers, [], true);

  // state에서 상태들을 꺼내준다
  const { loading, data: users, error } = state; 

  // 상태의 조건에 따라 렌더링한다
  if (loading) return <div>로딩중..</div>;
  if (error) return <div>에러가 발생했습니다</div>;
  if (!users) return <button onClick={refetch}>불러오기</button>;
  return ( 
    <>
      <ul>
        {users.map(user => (
          <li key={user.id}>
            {user.username} ({user.name})
          </li>
        ))}
      </ul>
      <button onClick={refetch}>다시 불러오기</button> // 원하는 곳에서 사용한다
    </>
  );
}
```