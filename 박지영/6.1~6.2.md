# 6. 리덕스
리덕스를 사용하면 여러분이 만들게 될 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜서 더욱 효율적으로 관리 할 수 있으며 글로벌 상태 관리도 손쉽게 할 수 있습니다.

Context API 와 useReducer Hook 을 사용해서 개발하는 흐름은 리덕스를 사용하는 것과 매우 개발 방식이 유사합니다.
### 리덕스를 사용하는 것 과 Context API를 사용하는 것의 차이
1. 미들웨어<br>
  리덕스에는 미들웨어(Middleware)라는 개념이 존재합니다. 리덕스로 상태 관리를 할 때 리듀서 함수를 사용합니다. 리덕스의 미들웨어를 사용하면 액션 객체가 리듀서에서 처리되기 전에 우리가 원하는 작업들을 수행 할 수 있습니다. (주로 비동기작업)
    - 특정 조건에 따라 액션이 무시되게 만들 수 있습니다.
    - 액션을 콘솔에 출력하거나, 서버쪽에 로깅을 할 수 있습니다.
    - 액션이 디스패치 됐을 때 이를 수정해서 리듀서에게 전달되도록 할 수 있습니다.
    - 특정 액션이 발생했을 때 이에 기반하여 다른 액션이 발생되도록 할 수 있습니다.
    - 특정 액션이 발생했을 때 특정 자바스크립트 함수를 실행시킬 수 있습니다.

2. 유용한 함수와, Hooks<br>
Context API 와 useReducer 를 사용 할 때에는 Context 도 새로 만들고, Context 의 Provider 설정도 하고 각 Context 를 편하게 사용하기 위해 전용 커스텀 Hook 을 따로 만들어서 사용하기도 했는데요, 리덕스에서는 이와 비슷한 작업을 편리하게 해줄 수 있는 여러 기능들이 존재합니다.

3. 하나의 커다란 상태<br>
Context API 를 사용해서 글로벌 상태를 관리 할 때에는 일반적으로 기능별로 Context를 만들어서 사용하는 것이 일반적입니다 (물론 꼭 그렇게 할 필요는 없습니다). 반면 리덕스에서는 **모든 글로벌 상태를 하나의 커다란 상태 객체에 넣어서 사용하는 것이 필수**입니다. 때문에 **매번 Context를 새로 만드는 수고로움을 덜 수 있습니다.**

### 리덕스를 언제 사용해야할까?
1. 프로젝트의 규모가 큰가?
Yes: 리덕스
No: Context API

2. 비동기 작업을 자주 하게 되는가?
Yes: 리덕스
No: Context API

3. 리덕스를 배워보니까 사용하는게 편한가?
Yes: 리덕스
No: Context API 또는 MobX

## 6.1 리덕스에서 사용되는 키워드 숙지하기
### 액션 (Action)
- 상태에 어떠한 변화가 필요하게 될 때 `action`을 발생시킨다.
- 이는 하나의 객체로 표현된다.
- 액션 객체는 `type` 필드는 필수이고 그 외의 값은 개발자 마음대로 생성
  ```js
  {
    type: "ADD_TODO",
    data: {
      id: 0,
      text: "리덕스 배우기"
    }
  }
  ```

### 액션 생성함수 (Action Creator)
- 액션을 만드는 함수.
- 파라미터를 받아와서 액션 객체 형태로 만들어준다.
- 액션 생성함수를 만들어서 사용하는 이유는 나중에 컴포넌트에서 더욱 쉽게 액션을 발생시키기 위함이다. 그래서 보통 함수 앞에 `export` 키워드를 붙여서 다른 파일에서 불러와서 사용한다.
  ```js
  export function addTodo(data) {
    return {
      type: "ADD_TODO",
      data
    };
  }

  // 화살표 함수로도 만들 수 있습니다.
  export const changeInput = text => ({
    type: "CHANGE_INPUT",
    text
  });
  ```

### 리듀서 (Reducer)
- 리듀서는 변화를 일으키는 함수이다. (`useReducer` 의 리듀서와 똑같은 형태)
- 현재의 상태와, 전달 받은 액션을 참고하여 새로운 상태를 만들어서 반환한다.
- `useReducer` 에선 일반적으로 `default:` 부분에 에러를 발생시키도록 처리하는게 일반적인 반면 리덕스의 리듀서에서는 기존 `state`를 그대로 반환하도록 작성해야한다.
- 여러개의 리듀서를 만들고 이를 합쳐서 루트 리듀서(Root Reducer)를 만들 수 있다. (루트 리듀서와 서브 리듀서)
  ```js
  function counter(state, action) {
    switch (action.type) {
      case 'INCREASE':
        return state + 1;
      case 'DECREASE':
        return state - 1;
      default:
        return state;
    }
  }
  ```

### 스토어 (Store)
- 한 애플리케이션당 하나의 스토어를 만든다.
- 현재의 앱 상태, 리듀서, 추가 **내장 함수**들이 있다.

### 디스패치 (dispatch)
- 스토어의 내장함수 중 하나로 액션을 발생 시키는 것이다.
- 액션을 파라미터로 전달한다. `dispatch(action)`

## 구독 (subscribe)
- 스토어의 내장함수 중 하나로 함수 형태의 값을 파라미터로 받아온다.
- subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출된다.
- 이 함수를 직접 사용하기보단 react-redux 라는 라이브러리에서 제공하는 `connect` 함수 또는 `useSelector` Hook 을 사용하여 리덕스 스토어의 상태에 구독한다.

## 6.2 리덕스의 3가지 규칙
### 1. 하나의 애플리케이션 하나의 스토어
특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있습니다. 하지만 개발 도구를 활용하지 못하게 됩니다.

### 2. 상태는 읽기전용 입니다. -> 불변성을 유지
- 새로운 상태를 생성하여 업데이트 해주는 방식은 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있습니다.

- 불변성을 유지하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 `shallow equality` 검사를 하기 때문입니다. 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 **겉핥기 식으로 비교를 하여 좋은 성능을 유지**할 수 있는 것이죠.

- `Immutable.js` 혹은 `Immer.js`로 불변성을 유지하며 상태를 관리
([리액트의 불변함, 그리고 컴포넌트에서 Immutable.js 사용하기](https://velopert.com/3486))

### 3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야 합니다.
순수한 함수
> 동일한 인풋 동일한 아웃풋<br>
- 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받습니다.
- 이전의 상태는 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환

new Date() 를 사용, 랜덤 숫자 생성, 네트워크에 요청 등... 리듀서 함수의 바깥에서 처리해야함. (리덕스 미들웨어 사용)
