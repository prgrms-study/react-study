# 1.22

## Context API를 사용한 전역 값 관리

Context API는 컴포넌트간의 prop으로 전달하는 번거로움을 해결하기 위해서 나왔다.

```jsx
const UserDispatch = React.createContext(null);
```

```jsx
// 제공
<UserDispatch.Provider value={value}>...</UserDispatch.Provider>;

// 소비
const use = useContext(UserDispatch);
```

... 내부에 들어가는 컴포넌트들은 언제든지 생성된 context api의 인스턴스에 등록된 값을 사용 할 수 있다.

createContext 에서 인자로 받는 defaultValue는 이럴때 사용된다.

```jsx
import { createContext, useContext } from "react";

const Context = createContext( "Default Value" );

function Child() {
  const context = useContext(Context);
  return <h2>Child1: {context}</h2>;
}

function Child2() {
  const context = useContext(Context);
  return <h2>Child2: {context}</h2>;
}

function App() {

  return (
    <>
      <Context.Provider value={ "Initial Value" }>
        <Child /> {/* Child inside Provider will get "Initial Value" */}
      </Context.Provider>
        <Child2 /> {/* Child outside Provider will get "Default Value" */}
    </>
  );
```

# 1.23

## Immer 를 사용한 더 쉬운 불변성 관리

```jsx
const object = {
  a: 1,
  b: 2,
};

const nextObject = {
  ...object,
  b: 3,
};
```

객체의 불변성을 지키기 위해서 직접적으로 객체의 속성에 접근하는거 보다는 새로운객체를 반환하는것이 좋다.
구조가 복잡한 객체를 수정할때에는 번거러운 작업이 동반되는데 이를 쉽게 해주기위해서 Immer를 사용한다.

```bash
$ yarn add immer
```

```jsx
import produce from "immer";

const state = {
  number: 1,
  dontChangeMe: 2,
};

const nextState = produce(state, (draft) => {
  draft.number += 1;
});
```

함수를 직접적으로 접근해서 변경을 하더라도 불변성을 지킬 수 있다.

# 1.24

## 클래스형 컴포넌트

```jsx
// 함수형 컴포넌트
function Hello({ color, name, isSpecial }) {
  return (
    <div style={{ color }}>
      {isSpecial && <b>*</b>}
      안녕하세요 {name}
    </div>
  );
}

Hello.defaultProps = {
  name: "이름없음",
};

export default Hello;
```

```jsx
// 클래스형 컴포넌트

class Hello extends Component {
  render() {
    const { color, name, isSpecial } = this.props;
    return (
      <div style={{ color }}>
        {isSpecial && <b>*</b>}
        안녕하세요 {name}
      </div>
    );
  }
}

Hello.defaultProps = {
  name: "이름없음",
};

export default Hello;
```

- 클래스에서는 class 컴포넌트명 extends Component 를 통해서 이 클래스가 React의 Component의 확장개념임을 명시해주어야 한다.
- 함수형 컴포넌트에서는 로직을 작성하고 마지막에 JSX를 반환하면 됬었지만 클래스형에서는 render 메서드를 정의하고 그 내부에 로직을 작성하고 return을 해야한다.
- 함수형에서는 props에 접근하기 위해서 인자에 넣는 형식이지만 클래스의 경우 this.props로 접근해야 한다.
- Hello.defaultProps로 prop 설정이 가능하지만 다른 방법으로

```jsx
  static defaultProps = {
    name: '이름없음'
  };
```

이런 식으로 클래스 내부에 static으로 defaultProps를 설정할수 있다.

- 메서드에 접근할때는 this.메서드명으로 접근해야한다.

```jsx
import React, { Component } from "react";

class Counter extends Component {
  handleIncrease = () => {
    console.log("increase"); //increase 출력
    console.log(this); // undefined 출력 , button이 출력되야하지않나??
  };

  handleDecrease = () => {
    console.log("decrease");
  };

  render() {
    return (
      <div>
        <h1>0</h1>
        <button onClick={this.handleIncrease}>+1</button>
        <button onClick={this.handleDecrease}>-1</button>
      </div>
    );
  }
}
```

# 1.25

## Life Cycle Method
